<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Automated refactorings for Ruby | @javiergelatti</title>
    <meta name="description" content="The personal website of Facundo Javier Gelatti">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/assets/style.CWGqcPrX.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/client-66tBtsv4.js"></script>
    <link rel="icon" href="/favicon.ico">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><main class="vp-doc"><article class="local-note content-viewer"><div style="position:relative;"><div><h1 id="automated-refactorings-for-ruby" tabindex="-1">Automated refactorings for Ruby <a class="header-anchor hash" href="#automated-refactorings-for-ruby" aria-label="Permalink to &quot;Automated refactorings for Ruby&quot;">&#x200b;</a></h1><table tabindex="0"><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>&#x2712;&#xfe0f; Description</strong></td><td>A RubyMine IDE plugin that implements various automated code refactorings for Ruby, developed based on real-world usage patterns.</td></tr><tr><td><strong>&#x26a1; Technologies</strong></td><td>Scala, JetBrains Platform SDK, Ruby</td></tr><tr><td><strong>&#x1f50c; Download</strong></td><td><a href="https://plugins.jetbrains.com/plugin/15312-rubyrefactorings" target="_blank" rel="noreferrer" class="external">JetBrains Marketplace</a></td></tr><tr><td><strong>&#x1f5c2;&#xfe0f; Source Code</strong></td><td><a href="https://github.com/javiergelatti/RubyRefactorings" target="_blank" rel="noreferrer" class="external">GitHub Repository</a></td></tr></tbody></table><h2 id="from-development-notes-to-a-working-implementation" tabindex="-1">From development notes to a working implementation <a class="header-anchor hash" href="#from-development-notes-to-a-working-implementation" aria-label="Permalink to &quot;From development notes to a working implementation&quot;">&#x200b;</a></h2><p>Refactoring &#x2014;making small, systematic changes to improve program structure without altering its behavior<sup class="footnote-ref"><a href="#fn1" id="fnref1" class="hash">[1]</a></sup>&#x2014; is a fundamental part of the software development process, especially when practicing Test-Driven Development. IDEs often offer automated refactoring tools, but their availability and sophistication vary significantly across different programming languages.</p><p>While working on a Ruby project, I frequently found myself wishing for more complete and robust refactoring support. Our team was using the RubyMine IDE by JetBrains, and the limitations of the automated refactoring tools were particularly noticeable, especially compared to those offered in IntelliJ IDEA &#x2014;another JetBrains IDE, primarily used for Java development.</p><p>I didn&#x2019;t want to just accept these limitations, so as an exercise, I started keeping a daily log of refactorings I would have used during my work, if only they were available<sup class="footnote-ref"><a href="#fn2" id="fnref2" class="hash">[2]</a></sup>:</p><p><img src="/assets/ruby-refactorings-notes.Dl8eRgTI.jpg" alt="A notebook page showing my handwritten notes with automated refactorings ideas."></p><p>Eventually, this led me to develop <em>RubyRefactorings</em>, a RubyMine plugin that would provide me with the automated refactorings I wanted to use while working on that project. My development notes helped me ensure I was focusing on real-world use cases drawn from my own experience.</p><p>The plugin is available <a href="https://github.com/javiergelatti/RubyRefactorings" target="_blank" rel="noreferrer" class="external">on GitHub</a>. It implements the refactoring transformations as <em>code intentions</em>, a term used on JetBrains IDEs to refer to contextual suggestions that appear when focusing on a particular expression in the code.</p><h2 id="some-of-the-implemented-refactorings" tabindex="-1">Some of the implemented refactorings <a class="header-anchor hash" href="#some-of-the-implemented-refactorings" aria-label="Permalink to &quot;Some of the implemented refactorings&quot;">&#x200b;</a></h2><p>The plugin provides many refactorings (though several from my original list remain unimplemented). I&#x2019;ll highlight some of them below.</p><h3 id="introduce-interpolation" tabindex="-1">Introduce interpolation <a class="header-anchor hash" href="#introduce-interpolation" aria-label="Permalink to &quot;Introduce interpolation&quot;">&#x200b;</a></h3><p>This is a simple refactoring that automates a transformation that&#x2019;s very cumbersome to perform manually: interpolating parts of an existing string literal. This is especially useful as a preliminary step before extracting parts of the string as variables, or when adding new dynamic contents to a string.</p><p>The animation below demonstrates some examples and edge cases<sup class="footnote-ref"><a href="#fn3" id="fnref3" class="hash">[3]</a></sup>: <img src="/assets/ruby-refactorings-example-0.CYAIYII2.gif" alt="Animation showing the &quot;introduce interpolation&quot; refactoring; the main example goes from &quot;hello, world&quot; to &quot;hello, #{&quot;world&quot;}&quot;."></p><h3 id="replace-conditional-with-guard-clause" tabindex="-1">Replace conditional with guard clause <a class="header-anchor hash" href="#replace-conditional-with-guard-clause" aria-label="Permalink to &quot;Replace conditional with guard clause&quot;">&#x200b;</a></h3><p>This refactoring is useful when you want to separate error or special cases from the main flow of the program, while also reducing conditional nesting<sup class="footnote-ref"><a href="#fn4" id="fnref4" class="hash">[4]</a></sup>:</p><p><img src="/assets/ruby-refactorings-example-1.8yIH3dyI.gif" alt="Animation showing an example of &quot;replace conditional with guard clause&quot;. One of the examples goes from &apos;if is_retired; retired_amount; else normal_pay_amount; end&apos; to &apos;return retired_amount if is_retired; normal_pay_amount&apos;"></p><p>Some cases require special handling, such as when working inside a block: <img src="/assets/ruby-refactorings-example-2.CGGe4zUz.gif" alt="Animation showing a special case of &quot;replace conditional with guard clause&quot;: when the conditional is inside a block it uses &apos;next&apos; instead of &apos;return&apos; to preserve the behavior of the code"></p><h3 id="extract-method-object" tabindex="-1">Extract method object <a class="header-anchor hash" href="#extract-method-object" aria-label="Permalink to &quot;Extract method object&quot;">&#x200b;</a></h3><p>This refactoring &#x2014;also known in the literature as &#x201c;replace function with command&#x201d;&#x2014; moves a method&#x2019;s logic to a new object:</p><p><img src="/assets/ruby-refactorings-example-3.Bq06xUD6.gif" alt="Animation showing the &quot;extract method object&quot; refactoring. It is applied to a method and generates a new class, such that the original method parameters are received in the constructor, and the logic is delegated to a new instance of that class. It also allows the user to rename the new class and message"></p><h3 id="introduce-chained-map" tabindex="-1">Introduce chained <code>map</code> <a class="header-anchor hash" href="#introduce-chained-map" aria-label="Permalink to &quot;Introduce chained `map`&quot;">&#x200b;</a></h3><p>This refactoring splits a <code>map</code>, <code>collect</code>, or <code>each</code> by introducing a chained <code>map</code>. You can use it to separate different steps used to process a collection, and it&#x2019;s usually followed by an application of the &#x201c;extract method&#x201d; refactoring.</p><p><img src="/assets/ruby-refactorings-example-4.EQPJgprT.gif" alt="Animation showing an example of &quot;introduce chained map&quot;. The example converts a single &apos;.map do&apos;, such that the result is obtained by first applying f and then g, to a chain of two &apos;.map do&apos;s: one applying f and the other applying g; allowing the user to choose the split point. The title of the code intention item includes an aside: &quot;may change semantics&quot;."></p><p>It is important to note that this preserves the behavior of the program only when <code>f</code> and <code>g</code> have no side effects, or when the order of their side effects is not relevant. That is the reason why the intention has the additional &#x201c;may change semantics&#x201d; warning, following the conventions of the IDE.</p><h3 id="other-refactorings" tabindex="-1">Other refactorings <a class="header-anchor hash" href="#other-refactorings" aria-label="Permalink to &quot;Other refactorings&quot;">&#x200b;</a></h3><p>Some additional automated refactorings implemented by the tool are:</p><ul><li>Convert single-quoted string to double-quoted (remarkably not built into RubyMine).</li><li>Remove useless conditional statement.</li><li>Move statement into conditional above.</li><li>Use self-assignment.</li></ul><p>Ruby-specific refactorings include:</p><ul><li>Replace singleton method by opening singleton class.</li><li>Remove unnecessary braces from hash argument.</li><li>Convert string/symbol word list to use array syntax.</li></ul><h2 id="some-technical-details" tabindex="-1">Some technical details <a class="header-anchor hash" href="#some-technical-details" aria-label="Permalink to &quot;Some technical details&quot;">&#x200b;</a></h2><p>The plugin is implemented in Scala using JetBrains&#x2019; Platform SDK. It was developed following strict Test-Driven Development practices. The test suite verifies both the detection of refactoring opportunities and the correctness of the transformations.</p><p>Much thought was given to make the tests readable by distilling their essential elements. As an example, here&#x2019;s a test case for the &#x201c;split map&#x201d; refactoring:</p><div class="language-scala vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">scala</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> splitsTheMapWhenThePartitionsShareMoreThanOneVariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Unit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  loadRubyFileWith(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |[1, 2, 3].&lt;caret&gt;map do |n|</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |  x = n + 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |  y = n + 2</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |  z = x + y</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  applySplitRefactor(splitPoint </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;y = n + 2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  expectResultingCodeToBe(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |[1, 2, 3].map do |n|</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |  x = n + 1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |  y = n + 2</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |  [x, y]</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |end.map do |x, y|</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |  z = x + y</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      |end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h2 id="conclusions" tabindex="-1">Conclusions <a class="header-anchor hash" href="#conclusions" aria-label="Permalink to &quot;Conclusions&quot;">&#x200b;</a></h2><p>Through this project, I&#x2019;ve learned that developing even small improvements for the tools we use can significantly impact our experience: reflecting on our work improves our capacity to envision new tools, and creating new tools deepens our knowledge of the craft. As a bonus, by making these refactorings available through intuitive interfaces, we help developers maintain cleaner, more maintainable code with less effort.</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>The term &#x201c;refactoring&#x201d; was popularized by Martin Fowler. From <a href="https://refactoring.com/" target="_blank" rel="noreferrer" class="external">refactoring.com</a>:</p><blockquote><p>Refactoring is a disciplined technique for restructuring an existing body of code, altering its internal structure without changing its external behavior.</p></blockquote><a href="#fnref1" class="footnote-backref hash">&#x21a9;&#xfe0e;</a></li><li id="fn2" class="footnote-item"><p>At the time, I was reading <em>The Reflective Practitioner</em> by Donald A. Sch&#xf6;n. This was one of the sources of inspiration for that reflective practice made &#x201c;in action&#x201d;, which includes recognizing something <em>as it happens</em> and making tacit knowledge (e.g. identifying and isolating a transformation as a refactoring) explicit. <a href="#fnref2" class="footnote-backref hash">&#x21a9;&#xfe0e;</a></p></li><li id="fn3" class="footnote-item"><p>Even a simple refactoring like this one has many edge cases. I call it &#x201c;simple&#x201d; because it only requires local information to be performed. <a href="#fnref3" class="footnote-backref hash">&#x21a9;&#xfe0e;</a></p></li><li id="fn4" class="footnote-item"><p>One could argue that it reduces the <em>explicit</em> nesting of conditionals, since in some way the conditions are still &#x201c;nested&#x201d;: the conditions below depend on the conditions above not having matched. <a href="#fnref4" class="footnote-backref hash">&#x21a9;&#xfe0e;</a></p></li></ol></section></div></div></article><svg xmlns="http://www.w3.org/2000/svg"/></main></div>
    
    
  </body>
</html>