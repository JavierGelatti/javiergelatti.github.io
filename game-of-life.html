<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Game of life inspector | @JavierGelatti online</title>
    <meta name="description" content="Website from @javiergelatti">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/assets/style.CM-KKCli.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/client-66tBtsv4.js"></script>
    <link rel="icon" href="/favicon.ico">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><main class="vp-doc"><article class="local-note content-viewer"><div style="position:relative;"><div><h1 id="game-of-life-inspector" tabindex="-1">Game of life inspector <a class="header-anchor hash" href="#game-of-life-inspector" aria-label="Permalink to &quot;Game of life inspector&quot;">&#x200b;</a></h1><h2 id="self-documenting-code-how" tabindex="-1">Self-documenting code: how? <a class="header-anchor hash" href="#self-documenting-code-how" aria-label="Permalink to &quot;Self-documenting code: how?&quot;">&#x200b;</a></h2><p>In many of the courses I&#x2019;ve taught, we talked about the importance of self-documenting code<sup class="footnote-ref"><a href="#fn1" id="fnref1" class="hash">[1]</a></sup>. Developers are often tempted to introduce explaining comments in their code, when they could have made the code more readable, eliminating the need to put the comments in.</p><p>The problem with comments is that they&#x2019;re not fully <em>connected</em> into the software we are making. A consequence of this is that the program implementation can diverge away from the comments that refer to it, leaving them outdated. There are large-scale studies<sup class="footnote-ref"><a href="#fn2" id="fnref2" class="hash">[2]</a></sup> that confirmed that, in most cases, <em>code and comments do not co-evolve</em>.</p><p>The usual advice given in these cases is to refactor the code by extracting some variables or methods, and improving names. While this is often enough, there are situations where something else might be needed.</p><hr><p>On one occasion, we were implementing Conway&#x2019;s Game of Life as a Test-Driven Development exercise, using Python. A typical test can look like this:</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">game </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GameOfLife({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Position(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), Position(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), Position(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">game.advance_generation()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.assertEquals(game.alive_cells(), {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Position(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), Position(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>The problem is that the starting and expected end state of the board are not obvious only by reading the code. One must look at the coordinates and imagine the board, acting like an interpreter of the program. Of course, this is problematic because parsing the board state by hand is not the problem we&#x2019;re trying to solve whenever we look at the tests&#x2026; and having to do it manually is both tiring and error-prone.</p><p>So, how could the code be written so that it&#x2019;s self-documenting, with the same expressiveness that we could have by looking at a diagram? Is it even possible to do it?</p><p>Well, one option could be to write a comment describing the state of the board in each case:</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">game </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GameOfLife({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # - - - -</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # - - * -</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # - * - -</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # - * - -</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # - - - -</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Position(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), Position(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), Position(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">game.advance_generation()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.assertEquals(game.alive_cells(), {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # - - - -</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # - - - -</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # - * * -</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # - - - -</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # - - - -</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Position(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), Position(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>However, despite this being easy to do, we obviously have the main inconvenience of comments we&#x2019;ve discussed before: nothing prevents them to expressing something different from what the code does.</p><blockquote><p>&#x1f4ad; You can think about this problem before reading on.</p></blockquote><h2 id="a-possible-tool" tabindex="-1">A possible tool <a class="header-anchor hash" href="#a-possible-tool" aria-label="Permalink to &quot;A possible tool&quot;">&#x200b;</a></h2><p>As I was thinking about this, fantasizing about what the best solution could be, I thought about the possibility of making an integrated tool to inspect code that defines a set of positions. So, I got to work and made a series of prototypes; here I&#x2019;ll show you the last one.</p><p>When your cursor is inside a set literal that has <code>Position</code>s as elements, you can inspect the expression to see a representation of the board: <img src="/assets/game-of-life-1.Dc9_TbWQ.gif" alt="An animated GIF showing a usage example of the tool. When selecting an expression and choosing to inspect it, the tool depicts a grid with alive cells at specific positions, such as (1, 3), (1, 2), and (2, 1), based on the inspected expression."></p><p>You can also interactively change the alive cells &#x2014;i.e. the positions that are elements of the set: <img src="/assets/game-of-life-2.DPceZTPO.gif" alt="An animated GIF that shows that if you click on the shown cells, their state is toggled between alive and dead (by adding or removing them from the set)."></p><p>As a result, this provides the best of both worlds: a visual representation of the board that&#x2019;s based on the actual code (and therefore cannot diverge and become outdated), and a back and forth connection between the graphical view and the textual view.</p><p>The tool works for Python in the JetBrains&#x2019; IDEs (like IntelliJ). I programmed it in Kotlin, using the <a href="https://github.com/dkandalov/live-plugin" target="_blank" rel="noreferrer" class="external">LivePlugin plugin</a> to be able to develop it interactively. The source is available <a href="https://gist.github.com/JavierGelatti/99fc50921c71b78c05c12908ff69c240" target="_blank" rel="noreferrer" class="external">here</a>.</p><h2 id="a-different-way-to-tackle-the-problem" tabindex="-1">A different way to tackle the problem <a class="header-anchor hash" href="#a-different-way-to-tackle-the-problem" aria-label="Permalink to &quot;A different way to tackle the problem&quot;">&#x200b;</a></h2><p>Another option to solve our original problem could be to make a test-specific mini-DSL<sup class="footnote-ref"><a href="#fn3" id="fnref3" class="hash">[3]</a></sup> to express the board states:</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">game </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.game_with_alive_cells(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    - - - -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    - - * -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    - * - -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    - * - -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    - - - -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">game.advance_generation()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.assert_alive_cells_in(game, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    - - - -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    - - - -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    - * * -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    - - - -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    - - - -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>In this case, we&#x2019;d have to implement methods for <code>game_with_alive_cells</code> and <code>assert_alive_cells_in</code> so that they parse the provided string and create the necessary <code>set</code>s of positions. With this, we&#x2019;ve also created a view so that the result of the code is not independent of the representation (therefore preventing inconsistencies). Of course, the parsing logic should be tested separately.</p><p>One characteristic of this approach is that the interface that we&#x2019;ve defined to see the board state is text-based. This gives us an advantage in terms of easiness of implementation: the tools we have and are accustomed to are text-based, and the APIs offered by programming languages implement lots of useful text-manipulation functions. However, this also constraints us: we cannot interact with the view except through text-manipulation commands, and cannot implement more complex views that don&#x2019;t map well to a text representation.</p><h2 id="closing-remarks" tabindex="-1">Closing remarks <a class="header-anchor hash" href="#closing-remarks" aria-label="Permalink to &quot;Closing remarks&quot;">&#x200b;</a></h2><p>We started by exploring some considerations regarding a specific case where the popular advice of &#x201c;writing self-documenting code&#x201d; and &#x201c;avoid code comments&#x201d; is not immediate to implement. One interesting aspect of this exploration was the possibility to think about better integrated tools, that are tailor-made to tackle a specific problem. The contrast of the two presented solutions gives us material to think about the bias we have for text-based tools.</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>A definition of self-documenting code can be found in the <a href="https://wiki.c2.com/?SelfDocumentingCode" target="_blank" rel="noreferrer" class="external">C2 Wiki</a>:</p><blockquote><p>Code that allegedly explains itself without the need for extraneous documentation, like flowcharts, UML diagrams, process-flow state diagrams, etc.</p></blockquote><a href="#fnref1" class="footnote-backref hash">&#x21a9;&#xfe0e;</a></li><li id="fn2" class="footnote-item"><p>Such as the article from F. Wen, C. Nagy, G. Bavota and M. Lanza, &#x201c;A Large-Scale Empirical Study on Code-Comment Inconsistencies,&#x201d; 2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC), Montreal, QC, Canada, 2019. <a href="https://csnagy.github.io/research/pdfs/2019/Wen2019-preprint.pdf" target="_blank" rel="noreferrer" class="external">PDF</a>. <a href="#fnref2" class="footnote-backref hash">&#x21a9;&#xfe0e;</a></p></li><li id="fn3" class="footnote-item"><p>DSL means Domain-Specific Language. In this context, I&#x2019;m referring to a text-based representation of the state of the board (using specific &#x2014;albeit very simple&#x2014; syntax inside a string literal), in order to make it easily readable. <a href="#fnref3" class="footnote-backref hash">&#x21a9;&#xfe0e;</a></p></li></ol></section></div></div></article><svg xmlns="http://www.w3.org/2000/svg"/></main></div>
    
    
  </body>
</html>