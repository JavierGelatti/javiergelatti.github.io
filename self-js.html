<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>A live JavaScript environment | @JavierGelatti online</title>
    <meta name="description" content="Website from @javiergelatti">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/assets/style.iEBQyGhj.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/client-DxbWe0Jw.js"></script>
    <link rel="icon" href="/favicon.ico">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><main class="vp-doc"><article class="local-note content-viewer"><div style="position:relative;"><div><h1 id="a-live-javascript-environment" tabindex="-1">A live JavaScript environment <a class="header-anchor hash" href="#a-live-javascript-environment" aria-label="Permalink to &quot;A live JavaScript environment&quot;">&#x200b;</a></h1><h2 id="static-definitions-vs-dynamic-objects" tabindex="-1">Static definitions vs. dynamic objects <a class="header-anchor hash" href="#static-definitions-vs-dynamic-objects" aria-label="Permalink to &quot;Static definitions vs. dynamic objects&quot;">&#x200b;</a></h2><p>While studying object-oriented programming, I&#x2019;ve frequently come across discussions about the pervasiveness of a &#x201c;class-oriented&#x201d; style: how our focus is on <em>classes</em> instead of <em>objects</em> while we are programming.</p><p>We can conjecture that one reason for this is that many languages provide syntax for classes, but not for objects. For example, if we program in Java, we&#x2019;re always &#x201c;writing classes&#x201d;; the <em>objects</em> &#x2014;i.e., the instances of those classes&#x2014; exist only when the program is running.</p><p>Most of those discussions are centered on the effects of those ways of thinking on software design, generally associating the &#x201c;class-oriented&#x201d; style with bad design. However, I&#x2019;m more interested in thinking about that discussion from another perspective, analyzing the separation of a static &#x201c;coding time&#x201d; and a dynamic &#x201c;run time&#x201d;, which are mutually exclusive. Let me explain.</p><h3 id="clarifying-the-vocabulary" tabindex="-1">Clarifying the vocabulary <a class="header-anchor hash" href="#clarifying-the-vocabulary" aria-label="Permalink to &quot;Clarifying the vocabulary&quot;">&#x200b;</a></h3><p>Going back to our conjecture, we could then say that languages providing &#x201c;syntax for objects&#x201d; will allow for &#x201c;truly&#x201d; object-oriented programming (as opposed to class-oriented programming). One example could be JavaScript, where we do have syntax for objects, not just classes:</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> anObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Pepe&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sayHi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `Hi, I&apos;m &#x24;{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>However, the validity of what we&#x2019;re saying depends on what we mean when we say &#x201c;object&#x201d;. If we dig deeper, we could say that what&#x2019;s shown in the code is not <em>really</em> an object; that&#x2019;s an <em>object literal</em>, which represents a static <em>definition</em> of an object but not the object itself (which will exist only when the program runs).</p><p>To make this distinction clearer, consider the following example:</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> personNamed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> anObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        sayHi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `Hi, I&apos;m &#x24;{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> anObject;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pepe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> personNamed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Pepe&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> marta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> personNamed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Marta&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>In this case, there&#x2019;s only <em>one</em> (1) object literal, but there will be <em>two</em> (2) objects created from it when we run the program. So a static definition used to create objects (i.e., the object literal) is not the same as the objects themselves.</p><p>The same thing happens with classes, especially if we consider that in many languages classes are also objects!<sup class="footnote-ref"><a href="#fn1" id="fnref1" class="hash">[1]</a></sup> This distinction lets us refine the previous discussion, allowing us to frame it differently and be more nuanced about it.</p><h2 id="the-direct-manipulation-of-objects" tabindex="-1">The direct manipulation of objects <a class="header-anchor hash" href="#the-direct-manipulation-of-objects" aria-label="Permalink to &quot;The direct manipulation of objects&quot;">&#x200b;</a></h2><p>So, if we use the word <em>object</em> to describe the dynamic runtime entities, then the only way a programming system can let you manipulate objects while you program is if it does not make a separation between a static &#x201c;coding time&#x201d; and the system&#x2019;s dynamic runtime.</p><p>In other words, the system <em>should not</em> force us to work in two separate stages:</p><ol><li>Changing the static definitions in the program<sup class="footnote-ref"><a href="#fn2" id="fnref2" class="hash">[2]</a></sup>.</li><li>Running the program and seeing the objects, without being able to change them.</li></ol><p>This is because, if we want to be able to directly manipulate and modify the objects, then we need the capabilities of (1) but while we are in (2), where the objects exist.</p><p>Some programming environments, such as the Smalltalk language, operate exactly in this manner. To describe the kind of direct access to the objects given by the live, integrated environment of Smalltalk, I like the following quote from Kent Beck<sup class="footnote-ref"><a href="#fn3" id="fnref3" class="hash">[3]</a></sup>:</p><blockquote><p>In Smalltalk, the objects are right there, an inch under the glass. You don&#x2019;t have a text editor that works on a stream of characters that&#x2019;s going to get interpreted, that&#x2019;s going to eventually turn into objects; you are working with the objects. You point at them, you click at them, you edit them; they are right there. You have no choice but to interact with the objects.</p></blockquote><p>This can also be experienced in a stronger way while using the Self language, a direct descendant of Smalltalk. In Self, you can see the objects and their connection to other objects, grab them, move them, and also evaluate code in their context:</p><p><img src="/assets/self-js-example-self.Cd4oygo8.png" alt="A screenshot of the Self programming environment, showing three outliners: one displays a &apos;point&apos; object with slots for x=1, y=2, and its parent slot; another for the &apos;traits point&apos; object, with a parent slot and a &apos;plus&apos; method; and the last one for the object &apos;2&apos;. The first outliner has visible lines connecting its parent slot to the second outliner, and the &apos;y&apos; slot with the third outliner. Each outliner also has a text box with three buttons underneath: &apos;Get it&apos;, &apos;Do it&apos; and &apos;Close&apos;."></p><p>In a way, Smalltalk and Self put the objects right in front of you, reducing the distance between you &#x2014;the programmer&#x2014; and the running system: working with objects by directly &#x201c;poking&#x201d; at them on the screen highly contrasts with the more traditional process of <em>modifying a text file &#x2192; compiling &#x2192; running</em>, that inserts layers of indirection between you and the running program.</p><h2 id="an-experiment-with-javascript" tabindex="-1">An experiment with JavaScript <a class="header-anchor hash" href="#an-experiment-with-javascript" aria-label="Permalink to &quot;An experiment with JavaScript&quot;">&#x200b;</a></h2><p>JavaScript is a widely used language that was in part inspired by Self, sharing many of its characteristics (such as being dynamically-typed and prototype-based). This connection made me wonder if we could experience JavaScript in an environment that offers the kind of direct object manipulation that made Self so unique. So, I started working on an experiment to make it happen.</p><p>Using TypeScript and the web browser&#x2019;s DOM, I developed an environment to visualize and manipulate JavaScript objects in real-time. The code is available <a href="https://github.com/javiergelatti/self-js" target="_blank" rel="noreferrer" class="external">on GitHub</a>, and you can experience it firsthand <a href="https://javiergelatti.xyz/self-js" target="_blank" rel="noreferrer" style="background: hsl(354, 100%, 40%)" class="local">here</a>.</p><p>The environment provides several features that embody the direct object manipulation style of Self. For example, you can visualize objects with their properties and connections to other objects, making the object graph tangible and explorable:</p><p><img src="/assets/self-js-example-js.CVmzbUBg.png" alt="A visualization of a JavaScript &apos;point&apos; object with properties _x:1 and _y:2, showing connections with its prototype and the number 2, which are also being visualized. The interface mimics Self&apos;s outliner style but uses JavaScript terminology, with a prototype slot instead of a parent slot, and a text field with &apos;Do it&apos; and &apos;Get it&apos; buttons below."></p><p>Properties can be rewired in real-time by dragging the visible connection that connects them with their value: <img src="/assets/self-js-rewiring.Dc362FoZ.gif" alt="Animation showing the following: an outliner for the &apos;point&apos; object is displayed, its _x property being connected to a number value &apos;1&apos;. There&apos;s also an outliner of another number value &apos;2&apos; below. The user grabs the arrow point with the cursor, and drops it into the outliner for the number 2. As a consequence, the value of the _x property of the point is changed to 2, and the arrow stays pointing to &apos;2&apos; instead of &apos;1&apos;, demonstrating the ability to modify property references in real-time."></p><p>Code can be evaluated in the context of any object, and its result can be inspected:</p><p><img src="/assets/self-js-evaluating.BjyJ3VR6.gif" alt="An animation showing the following interaction: in the outliner for the point object, input &apos;this.plus(this)&apos; and Get it; a new point object is displayed; then input &quot;this._x = 123&quot; and Do it; the value of the _x property of the point is changed to 123."></p><p>There are many other features of the system you can find by freely exploring it. An interesting one are the object and property attributes indicators, you can see them if you freeze an object by running <code>Object.freeze(this)</code>.</p><p>The system was programmed using TypeScript and the web browser&#x2019;s DOM. All the behavior was developed using Test-Driven Development, including comprehensive testing of view interactions (which is very uncommon). A special effort was done to be able to run the system in mobile devices with multitouch interfaces.</p><h2 id="conclusions" tabindex="-1">Conclusions <a class="header-anchor hash" href="#conclusions" aria-label="Permalink to &quot;Conclusions&quot;">&#x200b;</a></h2><p>While developing this environment I learned a lot of things about both JavaScript and live programming tools. Although there are many missing features, I feel it does let you experience some of the direct manipulation affordances given by the dynamic systems that inspired me, where the only thing between you and the objects is the glass of the screen.</p><p>This experiment also revealed both challenges and opportunities in modern programming environments: while today&#x2019;s development tools often maintain a strict separation between coding and runtime, alternative approaches are possible even in contemporary, mainstream languages. As we continue to evolve our programming tools and environments, it&#x2019;s worth reconsidering the assumptions we make about our craft. There&#x2019;s still much to learn from early systems like Smalltalk and Self, and their pioneering approaches to human-computer interaction in programming environments.</p><p>This project remains open for exploration and contribution, serving as both a practical tool and a reminder that the way we interact with our programming environments significantly impacts how we think about and work with objects in our code.</p><p><img src="/assets/self-js-color.DEFdmpK-.gif" alt="An HTMLDivElement object&apos;s color property is shown being connected to string values &apos;red&apos; and then changed to &apos;green&apos; by dragging and dropping the arrow. Each time the property is re-routed the div element changes its color on the screen, demonstrating the live DOM manipulation."></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>This is true in many languages, even in JavaScript. As a &#x2014;perhaps unusual&#x2014; example, we can adapt the previous code to define classes instead of using the object literal notation:</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> personNamed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> aClass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        static</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sayHi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `Hi, I&apos;m &#x24;{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> aClass;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pepe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> personNamed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Pepe&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> marta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> personNamed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Marta&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>The resulting objects will understand the <code>sayHi()</code> message producing the same result as before, albeit now being functions and having additional properties. <a href="#fnref1" class="footnote-backref hash">&#x21a9;&#xfe0e;</a></p></li><li id="fn2" class="footnote-item"><p>This is the process we earlier inaccurately called &#x201c;writing classes&#x201d;. We now understand that was really a particular case of creating <em>static</em> definitions <em>before running the program</em>, rather than working with (dynamic) objects while the program is running. <a href="#fnref2" class="footnote-backref hash">&#x21a9;&#xfe0e;</a></p></li><li id="fn3" class="footnote-item"><p>This is from the Ruby Rogues podcast book club, episode 23, minute 53:41; where they talked about the book &#x201c;Smalltalk Best Practice Patterns&#x201d;. You can listen to that episode <a href="https://podcasts.musixmatch.com/podcast/01hbps1dwrarm5ywrtwm9241x3/episode/01hqqv1m1teh4xcxrc8m2632e4" target="_blank" rel="noreferrer" class="external">here</a>. <a href="#fnref3" class="footnote-backref hash">&#x21a9;&#xfe0e;</a></p></li></ol></section></div></div></article><svg xmlns="http://www.w3.org/2000/svg"/></main></div>
    
    
  </body>
</html>